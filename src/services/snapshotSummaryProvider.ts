import * as path from "node:path";
import type { Snapshot } from "@snapback/contracts";
import * as vscode from "vscode";
import type { SnapshotStorage } from "../storage/types";
import { logger } from "../utils/logger.js";
import type {
	SnapshotSummary,
	SnapshotSummaryProvider,
} from "../views/types.js";

export class StorageSnapshotSummaryProvider implements SnapshotSummaryProvider {
	constructor(private readonly storage: SnapshotStorage) {}

	async listRecent(limit: number): Promise<SnapshotSummary[]> {
		const snapshots = await this.readAll();
		return snapshots
			.sort((a, b) => b.timestamp - a.timestamp)
			.slice(0, limit)
			.map((snapshot) => this.toSummary(snapshot));
	}

	async total(): Promise<number> {
		const snapshots = await this.readAll();
		return snapshots.length;
	}

	async forFile(target: string | vscode.Uri): Promise<SnapshotSummary[]> {
		const snapshots = await this.readAll();
		const targetPath = this.toRelativePath(target);

		return snapshots
			.filter((snapshot) => {
				const files = this.extractFiles(snapshot);
				return files.length === 0 || files.includes(targetPath);
			})
			.sort((a, b) => b.timestamp - a.timestamp)
			.map((snapshot) => this.toSummary(snapshot));
	}

	private async readAll(): Promise<Snapshot[]> {
		try {
			return (await this.storage.listSnapshots()) as unknown as Snapshot[];
		} catch (error) {
			logger.warn("StorageSnapshotSummaryProvider:listSnapshots", error);
			return [];
		}
	}

	private toSummary(snapshot: Snapshot): SnapshotSummary {
		// The semantic name (e.g., "Modified auth.ts") is stored in meta.name
		// It's generated by SnapshotNamingStrategy during snapshot creation
		const name =
			this.asString(snapshot.meta?.name) ||
			this.asString((snapshot as any).name); // Fallback for in-memory Snapshot type
		const files = this.extractFiles(snapshot);
		const description = this.asString(snapshot.meta?.description);

		return {
			id: snapshot.id,
			label:
				name || `Snapshot ${new Date(snapshot.timestamp).toLocaleString()}`,
			createdAt: snapshot.timestamp,
			description,
			filesChanged: files.length > 0 ? files.length : undefined,
			branch: this.asString(snapshot.meta?.branch),
		};
	}

	private extractFiles(snapshot: Snapshot): string[] {
		const files = snapshot.meta?.files;
		if (Array.isArray(files)) {
			// Ensure proper handling of file paths
			return files
				.map((f) => {
					// Handle both string and object file entries
					if (typeof f === "string") {
						return f;
					}
					// If file is an object with a path property
					if (f && typeof f === "object" && "path" in f) {
						return String(f.path);
					}
					// Fallback to string conversion
					return String(f);
				})
				.filter((f) => f.length > 0); // Remove empty strings
		}
		return [];
	}

	private toRelativePath(target: string | vscode.Uri): string {
		const absolute = typeof target === "string" ? target : target.fsPath;
		const workspace = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
		if (!workspace) {
			return path.normalize(absolute);
		}
		return path.relative(workspace, absolute);
	}

	private asString(value: unknown): string | undefined {
		return typeof value === "string" && value.trim().length > 0
			? value
			: undefined;
	}
}
